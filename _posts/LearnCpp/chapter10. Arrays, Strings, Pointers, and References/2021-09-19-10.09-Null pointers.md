---
title : "10.09 — Null pointers"
category :
    - LearnCpp
tag : 
    - C++
    - https://www.learncpp.com/
    - null value
    - null pointer
    - nullptr
    - std::nullptr_t
    - implementation
    - implementation-defined behavior
    - unspecified behavior
    - undefined behavior

toc: true  
toc_sticky: true 
use_math : true
---


## Null values and null pointers

Just like normal variables, pointers are not initialized when they are instantiated. Unless a value is assigned, a pointer will point to some garbage address by default.

Besides memory addresses, there is one additional value that a pointer can hold: a null value. A **null value** is a special value that means the pointer is not pointing at anything. A pointer holding a null value is called a **null pointer**.

In C++, we can assign a pointer a null value by initializing or assigning it the literal `0`:

```c++
// Assign a pointer a null value
// by initializing or assigning it the literal 0

float* ptr { 0 };  // ptr is now a null pointer

float* ptr2; // ptr2 is uninitialized
ptr2 = 0; // ptr2 is now a null pointer
```

**Pointers convert to boolean false if they are null, and boolean true if they are non-null.** Therefore, we can use a conditional to test whether a pointer is null or not:

```c++
double* ptr { 0 };

// pointers convert to boolean false if they are null,
// and boolean true if they are non-null
if (ptr)
    std::cout << "ptr is pointing to a double value.";
else
    std::cout << "ptr is a null pointer.";
```

>**Best practice**  
- Initialize your pointers to a null value if you’re not giving them another value.


## Indirection through null pointers

In the previous lesson, we noted that indirection through a garbage pointer would lead to undefined results. **Indirection through a null pointer also results in undefined behavior.** In most cases, it will crash your application.

>>>A **programming language implementation** is a system for executing computer programs. There are two general approaches to programming language implementation: interpretation and compilation.  
**Interpretation** is a method of executing a program. The program is read as input by an interpreter, which performs the actions written in the program.  
**Compilation** is a different process, where a compiler reads in a program, but instead of running the program, the compiler translates it into some other language, such as bytecode or machine code. The translated code may either be directly executed by hardware, or serve as input to another interpreter or another compiler.

>>>**Unspecified behavior** is behavior that may vary on different implementations of a programming language. A program can be said to contain unspecified behavior when its source code may produce an executable that exhibits different behavior when compiled on a different compiler, or on the same compiler with different settings, or indeed in different parts of the same executable. While the respective language standards or specifications may impose a range of possible behaviors, the exact behavior depends on the implementation and may not be completely determined upon examination of the program's source code. Unspecified behavior will often not manifest itself in the resulting program's external behavior, but it may sometimes lead to differing outputs or results, potentially causing portability problems.  
  
>>>>**To enable compilers to produce optimal code for their respective target platforms**, programming language standards do not always impose a certain specific behavior for a given source code construct. Failing to explicitly define the exact behavior of every possible program is not considered an error or weakness in the language specification, and doing so would be infeasible. In the C and C++ languages, such non-portable constructs are generally grouped into three categories: Implementation-defined, unspecified, and undefined behavior.  
The exact definition of **unspecified behavior** varies. In C++, it is defined as "behavior, for a well-formed program construct and correct data, that depends on the implementation." The C++ Standard also notes that the range of possible behaviors is usually provided. Unlike implementation-defined behavior, there is no requirement for the implementation to document its behavior. Similarly, the C Standard defines it as behavior for which the standard "provides two or more possibilities and imposes no further requirements on which is chosen in any instance". Unspecified behavior is different from **undefined behavior**. The latter is typically a result of an erroneous program construct or data, and no requirements are placed on the translation or execution of such constructs.

>>>C and C++ distinguish implementation-defined behavior from **unspecified behavior**. For **implementation-defined behavior**, the implementation must choose a particular behavior and document it. An example in C/C++ is the size of integer data types. The choice of behavior must be consistent with the documented behavior within a given execution of the program.


## The NULL macro

In C++, there is a special preprocessor macro called **`NULL`** (defined in the `<cstddef>` header). This macro was inherited from C, where it is commonly used to indicate a null pointer.

```c++
#include <cstddef> // for NULL

double* ptr { NULL }; // ptr is a null pointer
```

The value of `NULL` is **implementation defined**, but is **usually defined as the integer constant `0`**. Note: **as of C++11, `NULL` can be defined as `nullptr` instead** (which we’ll discuss in a bit).

>**Best practice**  
Because `NULL` is a preprocessor macro with an implementation defined value, avoid using `NULL`.


## The perils of using `0` (or `NULL`) for null pointers

Note that the value of `0` isn’t a pointer type, so assigning `0` (or `NULL`, pre-C++11) to a pointer to denote that the pointer is a null pointer is a little inconsistent. In rare cases, when used as a literal argument, it can even cause problems because the compiler can’t tell whether we mean a null pointer or the integer `0`:

```c++
#include <iostream>
#include <cstddef> // for NULL

void print(int x) {
    std::cout << "print(int): " << x << '\n';
}

void print(int* x) {
    if (!x)
        std::cout << "print(int*): null\n";
    else
        std::cout << "print(int*): " << *x << '\n';
}

int main() {
    int* x { NULL };
    print(x);   // calls print(int*) because x has type int*
    print(0);   // calls print(int) because 0 is an integer literal
    print(NULL);// likely calls print(int), although we probably wanted print(int*)
}
```

In the likely case where `NULL` is defined as value `0`, `print(NULL)` will call `print(int)`, not `print(int*)` like you might expect for a null pointer literal.


## `nullptr` in C++11

To address the above issues, C++11 introduces a new keyword called `nullptr`. **`nullptr`** is a keyword, much like the boolean keywords true and false are.

Starting with C++11, this should be favored instead of `0` when we want a null pointer:

```c++
// note: ptr is still an integer pointer, just set to a null value
int* ptr { nullptr }; 
```

C++ will implicitly convert `nullptr` to any pointer type. So in the above example, `nullptr` is implicitly converted to an integer pointer, and then the value of `nullptr` assigned to `ptr`. This has the **effect** of making integer pointer `ptr` a null pointer.

We can also call a function with a `nullptr` literal, which will match to any parameter that takes a pointer value:

```c++
#include <iostream>

void print(int x) {
    std::cout << "print(int): " << x << '\n';
}

void print(int* x) {
    if (!x)
        std::cout << "print(int*): null\n";
    else
        std::cout << "print(int*): " << *x << '\n';
}

int main() {
    int* x { nullptr };
    print(x);       // calls print(int*)

    print(nullptr); // calls print(int*) as desired
}
```

>**Best practice**  
- Use `nullptr` to initialize your pointers to a null value.


## `std::nullptr_t`

C++11 also introduces a new type called `std::nullptr_t` (in header `<cstddef>`). `std::nullptr_t` can *only* hold one value: `nullptr`! While this may seem kind of silly, it’s useful in one situation. If we want to write a function that accepts only a `nullptr` argument, what type do we make the parameter? The answer is `std::nullptr_t`.


```c++
#include <iostream>
#include <cstddef> // for std::nullptr_t

void doSomething(std::nullptr_t ptr) {
    std::cout << "in doSomething()\n";
}

int main() {
    // call doSomething with an argument of type std::nullptr_t
    doSomething(nullptr); 
}
```

You probably won’t ever need to use this, but it’s good to know, just in case.